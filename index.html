<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web BIP39</title>
    <style>
      body {
        overflow: hidden;
      }
    </style>
    <script src="./tailwind.js"></script>
    <script src="./word-list.js"></script>
  </head>

  <body>
    <div id="app" class="flex justify-center">
      <div class="w-[800px] min-w-[800px]">
        <div class="flex justify-center">
          <div class="text-xl">Deso key Generator</div>
        </div>
        <div class="flex justify-center">
          <div class="">
            Implementation of
            <a
              href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki"
              >Bitcoin BIP39</a
            >
            which allows for deterministic keys to be generated from easy to
            remember mnemonics.
          </div>
        </div>
        <div class="flex w-[500px] max-w-[500px] mx-auto">
          <div>
            <div>
              <input
                class="h-[11px]"
                id="generate-random"
                type="checkbox"
              /><label class="ml-1 text-[16px]">Pick mnemonic </label>
            </div>
            <!-- <div>
              <input
                class="h-[11px]"
                id="use-passphrase"
                type="checkbox"
              /><label class="ml-1">use passphrase</label>
            </div> -->
          </div>
        </div>
        <div class="flex justify-center mt-4">
          <button
            id="submit"
            class="bg-blue-700 py-2 px-6 border-stone-500 border-1 text-white rounded-lg"
          >
            generate mnemonic
          </button>
        </div>
        <div class="flex justify-center mt-4">
          <textarea
            id="mnemonic-input"
            class="border-2 border-black min-w-[500px] min-h-[200px] text-black"
            width="500"
          ></textarea>
        </div>

        <div class="flex justify-center mt-4">
          <div id="generated-mnemonic"></div>
        </div>
        <div class="flex justify-center">
          <a
            id="copy-button"
            class="cursor-pointer hover:underline text-blue-700 hidden"
            >copy</a
          >
        </div>
        <div
          class="flex flex-col justify-center mt-4 hidden"
          id="words-to-choose-from"
        >
          <div class="text-center">
            choose 12 words <span id="word-count">(0/12)</span
            ><span id="validate-mnemonic"></span>
          </div>
          <div
            id="words"
            class="flex justify-center border border-stone-500 p-2 flex-wrap max-w-[500px] mx-auto max-h-[500px] overflow-auto"
          ></div>
        </div>
      </div>
    </div>
    <!-- init state and event setting -->
    <script>
      const ui = {
        submitButton: document.getElementById("submit"),
        generatedMnemonic: document.getElementById("generated-mnemonic"),
        pickRandom: document.getElementById("generate-random"),
        usePassphrase: document.getElementById("use-passphrase"),
        mnemonicInput: document.getElementById("mnemonic-input"),
        copyButton: document.getElementById("copy-button"),
        wordsToChooseFrom: document.getElementById("words-to-choose-from"),
        wordCount: document.getElementById("word-count"),
        validateMnemonic: document.getElementById("validate-mnemonic"),
      };

      ui.copyButton.onclick = () => {
        navigator.clipboard.writeText(ui.mnemonicInput.value);
        ui.copyButton.innerText = "copied";
      };

      ui.submitButton.addEventListener("click", async () => {
        ui.copyButton.innerText = "copy";
        const mnemonic = await generateMnemonic(englishWordList, 128);
        ui.mnemonicInput.value = mnemonic;
        ui.copyButton.classList.remove("hidden");
      });
      ui.pickRandom.addEventListener("click", () => {
        ui.mnemonicInput.value = "";
        if (ui.pickRandom.checked) {
          ui.wordsToChooseFrom.classList.remove("hidden");
          ui.submitButton.disabled = true;

          ui.submitButton.classList.add("bg-stone-500");
        } else {
          ui.wordsToChooseFrom.classList.add("hidden");
          ui.submitButton.disabled = false;
          ui.submitButton.classList.remove("bg-stone-500");
        }
      });
    </script>
    <script>
      let selected = [];
      const clicked = {};
      englishWordList.forEach(async (word, index) => {
        const wordDiv = document.createElement("div");
        clicked[word] = "unselected";
        wordDiv.id = word;
        wordDiv.innerText = word;
        wordDiv.classList.add(["max-w-[80px]"]);
        wordDiv.classList.add(["min-w-[80px]"]);
        wordDiv.classList.add(["mx-3"]);
        wordDiv.classList.add(["cursor-pointer"]);
        wordDiv.classList.add(["hover:bg-blue-500"]);
        wordDiv.classList.add(["hover:text-white"]);
        wordDiv.classList.add(["text-center"]);
        wordDiv.classList.add(["rounded"]);
        wordDiv.classList.add(["p-2"]);
        wordDiv.classList.add(["m-1"]);
        document.getElementById("words").appendChild(wordDiv);

        wordDiv.onclick = async (e) => {
          // only allow selecting 12
          if (
            (selected.length >= 12 && clicked[word] == "unselected") ||
            clicked[word] === "checkSum"
          ) {
            alert("12 words already selected");
            return;
          }
          if (selected.length === 11 && clicked[word] !== "selected") {
            const validLastWords = await getLastValidWords(
              selected,
              englishWordList
            );
            if (!validLastWords.includes(wordDiv.innerText)) {
              alert("invalid final word");
              return;
            }
          }
          // clicking state update
          if (clicked[word] == "unselected" || clicked[word] === "checkSum") {
            clicked[word] = "selected";
          } else {
            clicked[word] = "unselected";
          }
          if (clicked[word] == "selected") {
            wordDiv.classList.add(["text-white"]);

            wordDiv.classList.remove(["text-black"]);
            wordDiv.classList.remove(["bg-green-500"]);
            wordDiv.classList.add(["bg-blue-500"]);
            selected.push(word);
          } else {
            wordDiv.classList.add(["text-black"]);
            wordDiv.classList.remove(["bg-blue-500"]);
            wordDiv.classList.remove(["text-white"]);
            selected = selected.filter((w) => w !== word);
          }
          if (selected.length === 11) {
            const validLastWords = await getLastValidWords(
              selected,
              englishWordList
            );
            console.log(validLastWords);
            validLastWords.forEach((w) => {
              const element = document.getElementById(w);
              element.classList.add("bg-green-500");
            });
          }
          if (selected.length === 12) {
            const isValid = await validateMnemonic(
              selected.join(" "),
              englishWordList
            );
            if (isValid) {
              ui.validateMnemonic.innerText = " mnemonic is valid";
              ui.validateMnemonic.classList.add("text-green-500");
              ui.validateMnemonic.classList.remove("text-red-500");
              ui.copyButton.classList.remove("hidden");
            } else {
              ui.validateMnemonic.innerText = " mnemonic is invalid";
              ui.validateMnemonic.classList.add("text-red-500");
              ui.validateMnemonic.classList.remove("text-green-500");
              ui.copyButton.classList.add("hidden");
            }
          }
          ui.wordCount.innerText = `(${selected.length}/12)`;
          ui.mnemonicInput.value = selected.join(" ");
        };
      });
    </script>
    <!-- crypto logic here -->
    <script>
      const crypto = window.crypto;
      const subtle = crypto.subtle ?? crypto.webkitSubtle;

      function utf8ToBytes(str) {
        return new TextEncoder().encode(str);
      }

      function toBytes(data) {
        if (typeof data === "string") data = utf8ToBytes(data);
        return data;
      }

      async function sha(algorithm, input) {
        const arrayBuffer = await subtle.digest(algorithm, toBytes(input));
        return new Uint8Array(arrayBuffer);
      }

      async function pbkdf2(
        hashAlgorithm,
        password,
        salt,
        iterations,
        byteLength
      ) {
        const baseKey = await subtle.importKey(
          "raw",
          toBytes(password),
          "PBKDF2",
          false,
          ["deriveBits"]
        );

        const arrayBuffer = await subtle.deriveBits(
          {
            name: "PBKDF2",
            hash: hashAlgorithm,
            salt: toBytes(salt),
            iterations,
          },
          baseKey,
          byteLength * 8
        );
        return new Uint8Array(arrayBuffer);
      }

      function randomBytes(byteLength) {
        return crypto.getRandomValues(new Uint8Array(byteLength));
      }

      function assert(condition, message) {
        if (!condition) {
          throw new Error(message);
        }
      }

      function padStart(str, length, padString) {
        while (str.length < length) {
          str = padString + str;
        }
        return str;
      }

      function binaryToByte(bin) {
        return parseInt(bin, 2);
      }

      function bytesToBinary(bytes) {
        return Array.from(bytes)
          .map((x) => padStart(x.toString(2), 8, "0"))
          .join("");
      }

      // Normalization replaces equivalent sequences of characters
      // so that any two texts that are equivalent will be reduced
      // to the same sequence of code points, called the normal form of the original text.
      function nfkd(str) {
        if (typeof str !== "string")
          throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
        return str.normalize("NFKD");
      }

      function normalize(str) {
        const norm = nfkd(str);
        const words = norm.split(" ");
        if (![12, 15, 18, 21, 24].includes(words.length))
          throw new Error("Invalid mnemonic");
        return { nfkd: norm, words };
      }

      function assertEntropy(entropy) {
        assert(
          entropy instanceof Uint8Array &&
            [16, 20, 24, 28, 32].includes(entropy.length),
          "Invalid entropy"
        );
      }

      /**
       * Generate mnemonic. Uses Cryptographically-Secure Random Number Generator.
       * @param wordlist imported wordlist for specific language
       * @param strength mnemonic strength 128-256 bits
       * @example
       * generateMnemonic(wordlist, 128)
       * // 'bunker expand insane mean adapt throw focus business network among cruel tomato'
       */
      async function generateMnemonic(wordlist, strength) {
        assert(
          Number.isSafeInteger(strength) &&
            strength > 0 &&
            strength <= 256 &&
            strength % 32 === 0,
          "Invalid strength"
        );
        return entropyToMnemonic(randomBytes(strength / 8), wordlist);
      }

      async function deriveChecksumBits(entropy) {
        const ENT = entropy.length * 8;
        const CS = ENT / 32;
        const hash = await sha("SHA-256", entropy);
        return bytesToBinary(hash).slice(0, CS);
      }

      /**
       * Converts mnemonic string to raw entropy in form of byte array.
       * @param mnemonic 12-24 words
       * @param wordlist imported wordlist for specific language
       * @return entropy
       * @example
       * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
       * await mnemonicToEntropy(mnem, wordlist)
       * // Produces
       * new Uint8Array([
       *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
       *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
       * ])
       */
      async function mnemonicToEntropy(mnemonic, wordlist) {
        const { words } = normalize(mnemonic);
        assert(words.length % 3 === 0, "Invalid mnemonic");
        // convert word indices to 11 bit binary strings
        const bits = words
          .map((word) => {
            const index = wordlist.indexOf(word);
            assert(index !== -1, "Invalid mnemonic");
            return padStart(index.toString(2), 11, "0");
          })
          .join("");
        // split the binary string into ENT/CS
        const dividerIndex = Math.floor(bits.length / 33) * 32;
        const entropyBits = bits.slice(0, dividerIndex);
        const checksumBits = bits.slice(dividerIndex);
        // calculate the checksum and compare
        const entropy = new Uint8Array(
          entropyBits.match(/(.{1,8})/g).map(binaryToByte)
        );
        assertEntropy(entropy);
        const newChecksum = await deriveChecksumBits(entropy);
        assert(newChecksum === checksumBits, "Invalid checksum");

        return entropy;
      }

      /**
       * Converts raw entropy in form of byte array to mnemonic string.
       * @param entropy byte array
       * @param wordlist imported wordlist for specific language
       * @returns 12-24 words
       * @example
       * const ent = new Uint8Array([
       *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
       *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
       * ]);
       * await entropyToMnemonic(ent, wordlist);
       * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
       */
      async function entropyToMnemonic(entropy, wordlist) {
        assertEntropy(entropy);
        const entropyBits = bytesToBinary(entropy);
        console.log("entropy =>", entropy); // uint8 array
        console.log("entropyBits =>", entropyBits); // binary string
        const checksumBits = await deriveChecksumBits(entropy);
        console.log("checksumBits =>", checksumBits); // binary string
        const bits = entropyBits + checksumBits;
        const chunks = bits.match(/(.{1,11})/g);
        const words = chunks.map((binary) => {
          const index = binaryToByte(binary);
          return wordlist[index];
        });
        return words.join(" ");
      }

      /**
       * Validates mnemonic for being 12-24 words contained in `wordlist`.
       */
      async function validateMnemonic(mnemonic, wordlist) {
        try {
          await mnemonicToEntropy(mnemonic, wordlist);
        } catch (e) {
          return false;
        }
        return true;
      }

      const salt = (passphrase) => nfkd(`mnemonic${passphrase}`);

      /**
       * Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
       * @param mnemonic 12-24 words
       * @param passphrase string that will additionally protect the key
       * @returns 64 bytes of key data
       * @example
       * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
       * await mnemonicToSeed(mnem, 'password');
       * // new Uint8Array([...64 bytes])
       */
      async function mnemonicToSeed(mnemonic, passphrase = "") {
        return pbkdf2(
          "SHA-512",
          normalize(mnemonic).nfkd,
          salt(passphrase),
          2048,
          64
        );
      }
      async function getLastValidWords(mnemonicWithoutFinalWord, wordlist) {
        let possibleLastWords = await Promise.all(
          englishWordList.map(async (lastWord) => {
            if (mnemonicWithoutFinalWord.includes(lastWord)) return; // if they already selected this word it can't be used
            const mnemonicAsString = mnemonicWithoutFinalWord.join(" ");
            try {
              const results = await mnemonicToEntropy(
                `${mnemonicAsString} ${lastWord}`,
                wordlist
              ); // convert it to entropy, if non error response means its correct
              return lastWord;
              console.log(`last word ${lastWord} =>`, results);
            } catch {
              return;
            }
          })
        );
        return (possibleLastWords = possibleLastWords.filter((r) => r));
      }
      // async function testValidation(mnemonic, wordlist) {
      //   const INVALID_ENTROPY = "invalid entropy";
      //   wordlist = wordlist;
      //   if (!wordlist) {
      //     throw new Error("no word list");
      //   }

      //   const words = mnemonic.join(" ").normalize("NFKD").split(" ");
      //   if (words.length % 3 !== 0) {
      //     throw new Error("invalid mnemonic");
      //   }
      //   // convert word indices to 11 bit binary strings
      //   const bits = words
      //     .map((word) => {
      //       const index = wordlist.indexOf(word);
      //       if (index === -1) {
      //         throw new Error("invalid mnemonic");
      //       }
      //       return lpad(index.toString(2), "0", 11);
      //     })
      //     .join("");
      //   // split the binary string into ENT/CS
      //   const dividerIndex = Math.floor(bits.length / 33) * 32;
      //   const entropyBits = bits.slice(0, dividerIndex);
      //   const checksumBits = bits.slice(dividerIndex);
      //   // calculate the checksum and compare
      //   const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
      //   if (entropyBytes.length < 16) {
      //     throw new Error(INVALID_ENTROPY);
      //   }
      //   if (entropyBytes.length > 32) {
      //     throw new Error(INVALID_ENTROPY);
      //   }
      //   if (entropyBytes.length % 4 !== 0) {
      //     throw new Error(INVALID_ENTROPY);
      //   }
      //   const entropy = bytesToBinary(entropyBytes);
      //   const newChecksum = await deriveChecksumBits(entropy);
      //   console.log(newChecksum);
      //   if (newChecksum !== checksumBits) {
      //     throw new Error("invalid checksum");
      //   }
      //   return entropy.toString("hex");
      // }
      function lpad(str, padString, length) {
        while (str.length < length) {
          str = padString + str;
        }
        return str;
      }
    </script>
  </body>
</html>
