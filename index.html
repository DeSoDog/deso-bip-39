<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DeSo BIP39</title>
    <style>
      body {
        overflow: hidden;
      }
    </style>
    <link rel="icon" href="./deso-logo.png" />
    <script src="./tailwind.js"></script>
    <script src="./word-list.js"></script>
  </head>

  <body class="bg-stone-200">
    <div id="app" class="flex justify-center">
      <div class="w-[800px] min-w-[800px]">
        <div class="flex justify-center">
          <div class="text-xl my-2">
            Deso key Generator
            <img
              src="./deso-logo.png"
              height="150"
              width="150"
              class="mx-auto"
            />
          </div>
        </div>
        <div class="flex justify-center">
          <div class="mb-2">
            Implementation of
            <a
              class="underline text-blue-500 hover:text-purple-500"
              href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki"
              >BIP39</a
            >
            which allows for deterministic keys to be generated from easy to
            remember mnemonics.
          </div>
        </div>
        <div class="flex w-[800px] max-w-[800px] mx-auto mb-2">
          <div>
            <input
              class="h-[11px]"
              id="generate-random"
              type="checkbox"
            /><label class="ml-1 text-[16px]">Pick mnemonic </label>
          </div>
        </div>
        <div class="flex justify-center">
          <button
            id="submit"
            class="bg-blue-700 py-2 px-6 border-stone-500 border-1 text-white rounded-lg"
          >
            generate mnemonic
          </button>
        </div>
        <div class="flex justify-center mt-2">
          <textarea
            id="mnemonic-input"
            class="border-2 border-stone-500 min-w-[800px] min-h-[200px] border-1 bg-white"
            width="500"
            disabled
          ></textarea>
        </div>

        <div class="flex justify-center mt-2">
          <div id="generated-mnemonic"></div>
        </div>
        <div class="flex justify-center">
          <a
            id="copy-button"
            class="cursor-pointer hover:underline text-blue-700 hidden"
            >copy</a
          >
        </div>
        <div
          class="flex flex-col justify-center hidden"
          id="words-to-choose-from"
        >
          <div class="flex justify-around my-2">
            <div class="flex justify-content">
              <div
                class="bg-blue-500 h-[10px] w-[10px] mt-auto mb-[5px] mr-[5px]"
              ></div>
              <div class="mt-auto text-bottom">selected words</div>
            </div>
            <div class="text-center">
              <div class="text-center">
                choose 12 words <span id="word-count">(0/12)</span>
              </div>
              <span id="validate-mnemonic"></span>
            </div>
            <div class="flex justify-content">
              <div
                class="bg-green-500 h-[10px] w-[10px] mt-auto mb-[5px] mr-[5px]"
              ></div>
              <div class="mt-auto text-bottom">viable last words</div>
            </div>
          </div>
          <div
            id="words"
            class="flex justify-center border border-stone-500 p-2 flex-wrap max-w-[800px] mx-auto max-h-[500px] overflow-auto bg-white"
          ></div>
        </div>
      </div>
    </div>
    <!-- init state and event setting -->
    <script>
      const ui = {
        submitButton: document.getElementById("submit"),
        generatedMnemonic: document.getElementById("generated-mnemonic"),
        pickRandom: document.getElementById("generate-random"),
        usePassphrase: document.getElementById("use-passphrase"),
        mnemonicInput: document.getElementById("mnemonic-input"),
        copyButton: document.getElementById("copy-button"),
        wordsToChooseFrom: document.getElementById("words-to-choose-from"),
        wordCount: document.getElementById("word-count"),
        validateMnemonic: document.getElementById("validate-mnemonic"),
      };

      ui.copyButton.onclick = () => {
        navigator.clipboard.writeText(ui.mnemonicInput.value);
        ui.copyButton.innerText = "copied";
      };

      ui.submitButton.addEventListener("click", async () => {
        ui.copyButton.innerText = "copy";
        const mnemonic = await generateMnemonic(englishWordList, 128);
        ui.mnemonicInput.value = mnemonic;
        ui.copyButton.classList.remove("hidden");
      });

      ui.pickRandom.addEventListener("click", () => {
        resetState();
        if (ui.pickRandom.checked) {
          ui.wordsToChooseFrom.classList.remove("hidden");
          ui.submitButton.disabled = true;

          ui.submitButton.classList.add("bg-stone-500");
        } else {
          ui.wordsToChooseFrom.classList.add("hidden");
          ui.submitButton.disabled = false;
          ui.submitButton.classList.remove("bg-stone-500");
        }
      });
    </script>

    <script>
      let selected = [];
      const clicked = {};
      englishWordList.forEach(async (word, index) => {
        const wordDiv = document.createElement("div");
        clicked[word] = "unselected";
        wordDiv.id = word;
        wordDiv.innerText = word;
        wordDiv.classList.add(["max-w-[80px]"]);
        wordDiv.classList.add(["min-w-[80px]"]);
        wordDiv.classList.add(["mx-3"]);
        wordDiv.classList.add(["cursor-pointer"]);
        wordDiv.classList.add(["hover:bg-blue-500"]);
        wordDiv.classList.add(["hover:text-white"]);
        wordDiv.classList.add(["text-center"]);
        wordDiv.classList.add(["rounded"]);
        wordDiv.classList.add(["p-2"]);
        wordDiv.classList.add(["m-1"]);
        document.getElementById("words").appendChild(wordDiv);

        wordDiv.onclick = async (e) => {
          // only allow selecting 12
          if (
            (selected.length >= 12 && clicked[word] == "unselected") ||
            (selected.length >= 12 && clicked[word] == "checkSum")
          ) {
            alert("12 words already selected");
            return;
          }

          // validate the word they selected is acceptable
          if (selected.length === 11 && clicked[word] !== "selected") {
            const validLastWords = await getLastValidWords(
              selected,
              englishWordList
            );
            if (!validLastWords.includes(wordDiv.innerText)) {
              alert("invalid final word");
              return;
            }
          }
          // clicking state update
          if (clicked[word] == "unselected" || clicked[word] === "checkSum") {
            clicked[word] = "selected";
            selectButton(wordDiv);
          } else {
            clicked[word] = "unselected";
            unselectButton(wordDiv);
          }

          // if they unselect the 11th word we need to clear out the green words
          englishWordList
            .filter((w) => clicked[w] === "checkSum")
            .forEach(unsetButtonCheckSum);

          if (selected.length === 11) {
            setPossibleLastWordSelection();
          } else if (selected.length === 12) {
            const isValid = await validateMnemonic(
              selected.join(" "),
              englishWordList
            );
            isValid ? setValid() : setInvalid();
          }
          ui.wordCount.innerText = `(${selected.length}/12)`;
          ui.mnemonicInput.value = selected.join(" ");
        };
      });
    </script>
    <!-- UI helpers here -->
    <script>
      const setInvalid = () => {
        ui.validateMnemonic.innerText = " mnemonic is invalid";
        ui.validateMnemonic.classList.add("text-red-500");
        ui.validateMnemonic.classList.remove("text-green-500");
        ui.copyButton.classList.add("hidden");
      };
      const setValid = () => {
        ui.validateMnemonic.innerText = " mnemonic is valid";
        ui.validateMnemonic.classList.add("text-green-500");
        ui.validateMnemonic.classList.remove("text-red-500");
        ui.copyButton.classList.remove("hidden");
      };
      const setPossibleLastWordSelection = async () => {
        // unselect any previously selected words
        const validLastWords = await getLastValidWords(
          selected,
          englishWordList
        );
        englishWordList
          .filter((w) => clicked[w] === "checkSum")
          .forEach((w) => {
            unsetButtonCheckSum(w);
          });
        // select the new correct ones
        validLastWords.forEach((w) => {
          setButtonCheckSum(w);
        });
      };
      const selectButton = (wordDiv) => {
        wordDiv.classList.add(["text-white"]);
        wordDiv.classList.remove(["text-black"]);
        wordDiv.classList.remove(["bg-green-500"]);
        wordDiv.classList.add(["bg-blue-500"]);
        selected.push(wordDiv.innerText);
      };
      const unselectButton = (wordDiv) => {
        wordDiv.classList.add(["text-black"]);
        wordDiv.classList.remove(["bg-blue-500"]);
        wordDiv.classList.remove(["bg-green-500"]);
        wordDiv.classList.remove(["text-white"]);
        ui.copyButton.classList.add("hidden");
        selected = selected.filter((w) => w !== wordDiv.innerText);
        ui.validateMnemonic.innerText = "";
      };
      const unsetButtonCheckSum = (word) => {
        clicked[word] = "unselected";
        const element = document.getElementById(word);
        unselectButton(element);
      };
      const setButtonCheckSum = (word) => {
        const element = document.getElementById(word);
        element.classList.add("bg-green-500");
        clicked[word] = "checkSum";
      };
      const resetState = () => {
        ui.copyButton.classList.add("hidden");
        ui.mnemonicInput.value = "";
        englishWordList
          .filter((w) => clicked[w] !== "unselected")
          .forEach((w) => unselectButton(document.getElementById(w)));
      };
    </script>
    <!-- crypto logic here -->
    <script>
      const crypto = window.crypto;
      const subtle = crypto.subtle ?? crypto.webkitSubtle;

      function utf8ToBytes(str) {
        return new TextEncoder().encode(str);
      }

      function toBytes(data) {
        if (typeof data === "string") data = utf8ToBytes(data);
        return data;
      }

      async function sha(algorithm, input) {
        const arrayBuffer = await subtle.digest(algorithm, toBytes(input));
        return new Uint8Array(arrayBuffer);
      }

      async function pbkdf2(
        hashAlgorithm,
        password,
        salt,
        iterations,
        byteLength
      ) {
        const baseKey = await subtle.importKey(
          "raw",
          toBytes(password),
          "PBKDF2",
          false,
          ["deriveBits"]
        );

        const arrayBuffer = await subtle.deriveBits(
          {
            name: "PBKDF2",
            hash: hashAlgorithm,
            salt: toBytes(salt),
            iterations,
          },
          baseKey,
          byteLength * 8
        );
        return new Uint8Array(arrayBuffer);
      }

      function randomBytes(byteLength) {
        return crypto.getRandomValues(new Uint8Array(byteLength));
      }

      function assert(condition, message) {
        if (!condition) {
          throw new Error(message);
        }
      }

      function padStart(str, length, padString) {
        while (str.length < length) {
          str = padString + str;
        }
        return str;
      }

      function binaryToByte(bin) {
        return parseInt(bin, 2);
      }

      function bytesToBinary(bytes) {
        return Array.from(bytes)
          .map((x) => padStart(x.toString(2), 8, "0"))
          .join("");
      }

      function nfkd(str) {
        if (typeof str !== "string")
          throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
        return str.normalize("NFKD");
      }

      function normalize(str) {
        const norm = nfkd(str);
        const words = norm.split(" ");
        if (![12, 15, 18, 21, 24].includes(words.length))
          throw new Error("Invalid mnemonic");
        return { nfkd: norm, words };
      }

      function assertEntropy(entropy) {
        assert(
          entropy instanceof Uint8Array &&
            [16, 20, 24, 28, 32].includes(entropy.length),
          "Invalid entropy"
        );
      }

      async function generateMnemonic(wordlist, strength) {
        assert(
          Number.isSafeInteger(strength) &&
            strength > 0 &&
            strength <= 256 &&
            strength % 32 === 0,
          "Invalid strength"
        );
        return entropyToMnemonic(randomBytes(strength / 8), wordlist);
      }

      async function deriveChecksumBits(entropy) {
        const ENT = entropy.length * 8;
        const CS = ENT / 32;
        const hash = await sha("SHA-256", entropy);
        return bytesToBinary(hash).slice(0, CS);
      }

      async function mnemonicToEntropy(mnemonic, wordlist) {
        const { words } = normalize(mnemonic);
        assert(words.length % 3 === 0, "Invalid mnemonic");
        // convert word indices to 11 bit binary strings
        const bits = words
          .map((word) => {
            const index = wordlist.indexOf(word);
            assert(index !== -1, "Invalid mnemonic");
            return padStart(index.toString(2), 11, "0");
          })
          .join("");
        // split the binary string into ENT/CS
        const dividerIndex = Math.floor(bits.length / 33) * 32;
        const entropyBits = bits.slice(0, dividerIndex);
        const checksumBits = bits.slice(dividerIndex);
        // calculate the checksum and compare
        const entropy = new Uint8Array(
          entropyBits.match(/(.{1,8})/g).map(binaryToByte)
        );
        assertEntropy(entropy);
        const newChecksum = await deriveChecksumBits(entropy);
        assert(newChecksum === checksumBits, "Invalid checksum");

        return entropy;
      }

      async function entropyToMnemonic(entropy, wordlist) {
        assertEntropy(entropy);
        const entropyBits = bytesToBinary(entropy);
        const checksumBits = await deriveChecksumBits(entropy);
        const bits = entropyBits + checksumBits;
        const chunks = bits.match(/(.{1,11})/g);
        const words = chunks.map((binary) => {
          const index = binaryToByte(binary);
          return wordlist[index];
        });
        return words.join(" ");
      }

      async function validateMnemonic(mnemonic, wordlist) {
        try {
          await mnemonicToEntropy(mnemonic, wordlist);
        } catch (e) {
          return false;
        }
        return true;
      }

      const salt = (passphrase) => nfkd(`mnemonic${passphrase}`);

      async function mnemonicToSeed(mnemonic, passphrase = "") {
        return pbkdf2(
          "SHA-512",
          normalize(mnemonic).nfkd,
          salt(passphrase),
          2048,
          64
        );
      }

      async function getLastValidWords(mnemonicWithoutFinalWord, wordlist) {
        let possibleLastWords = await Promise.all(
          englishWordList.map(async (lastWord) => {
            if (mnemonicWithoutFinalWord.includes(lastWord)) return; // if they already selected this word it can't be used
            const mnemonicAsString = mnemonicWithoutFinalWord.join(" ");
            try {
              const results = await mnemonicToEntropy(
                `${mnemonicAsString} ${lastWord}`,
                wordlist
              ); // convert it to entropy, if non error response means its correct
              return lastWord;
            } catch {
              return;
            }
          })
        );
        return (possibleLastWords = possibleLastWords.filter((r) => r));
      }

      function lpad(str, padString, length) {
        while (str.length < length) {
          str = padString + str;
        }
        return str;
      }
    </script>
  </body>
</html>
