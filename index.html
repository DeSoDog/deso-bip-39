<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Web BIP39</title>
  <style>
    body {
      overflow: hidden;
    }
  </style>

  <script src="./tailwind.js"></script>
  <script src="./word-list.js"></script>
</head>

<body>
  <div id="app" class="flex justify-center">
    <div class="w-[800px] min-w-[800px]">
      <div class="flex justify-center">
        <div class="text-xl">
          Deso key Generator
        </div>
      </div>
      <div class="flex justify-center">
        <div class="">
          Implementation of <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">Bitcoin BIP39</a>
          which allows for deterministic keys to be generated from easy to remember mnemonics.
        </div>
      </div>
      <div class="flex w-[500px] max-w-[500px] mx-auto">
        <div>
          <div> <input class="h-[11px]" id="generate-random" type="checkbox" /><label class="ml-1 text-[16px]">generate
              random</label>
          </div>
          <div> <input class="h-[11px]" id="use-passphrase" type="checkbox" /><label class="ml-1">use passphrase</label>
          </div>
        </div>
      </div>
      <div class="flex justify-center mt-4">
        <textarea id="mnemonic-input" class="border-2 border-black min-w-[500px] min-h-[200px] text-black"
          width="500"></textarea>
      </div>
      <div class="flex justify-center mt-4">
        <button id="submit" class="bg-blue-700 py-2 px-6 border-stone-500 border-1 text-white rounded-lg">generate
          mnemonic</button>
      </div>
      <div class="flex justify-center mt-4">

        <div id='generated-mnemonic'>
        </div>
      </div>

      <div class="flex justify-center">
        <a id="copy-button" class="cursor-pointer hover:underline text-blue-700 hidden">copy</a>
      </div>
    </div>
  </div>
  <script>
    const ui = {
      submitButton: document.getElementById("submit"),
      generatedMnemonic: document.getElementById("generated-mnemonic"),
      generateRandom: document.getElementById("generate-random"),
      usePassphrase: document.getElementById("use-passphrase"),
      mnemonicInput: document.getElementById("mnemonic-input"),
      copyButton: document.getElementById("copy-button"),
    }

    ui.copyButton.onclick = () => {
      navigator.clipboard.writeText(ui.generatedMnemonic.innerText);
      ui.copyButton.innerText ="copied"
    }


    ui.submitButton.addEventListener('click', async () => {
      ui.copyButton.innerText ="copy"
      const mnemonic = await generateMnemonic(englishWordList, 128)
      ui.generatedMnemonic.innerText = mnemonic
      ui.copyButton.classList.remove('hidden')
    })

    ui.generateRandom.addEventListener('click', () => {
      console.log(ui.generateRandom.checked)
      ui.mnemonicInput.disabled = ui.generateRandom.checked
      console.log(ui.mnemonicInput)
    })

    ui.generateRandom.click()
  </script>
  <script>


    const crypto = window.crypto;
    const subtle = crypto.subtle ?? crypto.webkitSubtle;

    function utf8ToBytes(str) {
      return new TextEncoder().encode(str);
    }

    function toBytes(data) {
      if (typeof data === 'string') data = utf8ToBytes(data);
      return data;
    }

    async function sha(
      algorithm,
      input
    ) {
      const arrayBuffer = await subtle.digest(algorithm, toBytes(input));
      return new Uint8Array(arrayBuffer);
    }

    async function pbkdf2(
      hashAlgorithm,
      password,
      salt,
      iterations,
      byteLength
    ) {

      const baseKey = await subtle.importKey(
        'raw',
        toBytes(password),
        'PBKDF2',
        false,
        ['deriveBits']
      );

      const arrayBuffer = await subtle.deriveBits(
        {
          name: 'PBKDF2',
          hash: hashAlgorithm,
          salt: toBytes(salt),
          iterations,
        },
        baseKey,
        byteLength * 8
      );
      return new Uint8Array(arrayBuffer);
    }

    function randomBytes(byteLength) {
      return crypto.getRandomValues(new Uint8Array(byteLength));
    }

    function assert(
      condition,
      message
    ) {
      if (!condition) {
        throw new Error(message);
      }
    }

    function padStart(
      str,
      length,
      padString,
    ) {
      while (str.length < length) {
        str = padString + str;
      }
      return str;
    }

    function binaryToByte(bin) {
      return parseInt(bin, 2);
    }

    function bytesToBinary(bytes) {
      return Array.from(bytes).map(x => padStart(x.toString(2), 8, '0')).join('');
    }
    // Is japanese wordlist
    const isJapanese = (wordlist) => wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093';

    // Normalization replaces equivalent sequences of characters
    // so that any two texts that are equivalent will be reduced
    // to the same sequence of code points, called the normal form of the original text.
    function nfkd(str) {
      if (typeof str !== 'string') throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
      return str.normalize('NFKD');
    }

    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(' ');
      if (![12, 15, 18, 21, 24].includes(words.length)) throw new Error('Invalid mnemonic');
      return { nfkd: norm, words };
    }

    function assertEntropy(entropy) {
      assert(
        entropy instanceof Uint8Array &&
        [16, 20, 24, 28, 32].includes(entropy.length),
        'Invalid entropy'
      );
    }

    /**
     * Generate mnemonic. Uses Cryptographically-Secure Random Number Generator.
     * @param wordlist imported wordlist for specific language
     * @param strength mnemonic strength 128-256 bits
     * @example
     * generateMnemonic(wordlist, 128)
     * // 'bunker expand insane mean adapt throw focus business network among cruel tomato'
     */
    async function generateMnemonic(wordlist, strength) {
      assert(
        Number.isSafeInteger(strength) &&
        strength > 0 &&
        strength <= 256 &&
        strength % 32 === 0,
        'Invalid strength'
      );
      return entropyToMnemonic(randomBytes(strength / 8), wordlist);
    }

    async function deriveChecksumBits(entropy) {
      const ENT = entropy.length * 8;
      const CS = ENT / 32;
      const hash = await sha('SHA-256', entropy);
      return bytesToBinary(hash).slice(0, CS);
    }

    /**
     * Converts mnemonic string to raw entropy in form of byte array.
     * @param mnemonic 12-24 words
     * @param wordlist imported wordlist for specific language
     * @return entropy
     * @example
     * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
     * await mnemonicToEntropy(mnem, wordlist)
     * // Produces
     * new Uint8Array([
     *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
     *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
     * ])
     */
    async function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize(mnemonic);
      assert(
        words.length % 3 === 0,
        'Invalid mnemonic'
      );
      // convert word indices to 11 bit binary strings
      const bits = words
        .map((word) => {
          const index = wordlist.indexOf(word);
          assert(
            index !== -1,
            'Invalid mnemonic'
          );
          return padStart(index.toString(2), 11, '0');
        })
        .join('');
      // split the binary string into ENT/CS
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      // calculate the checksum and compare
      const entropy = new Uint8Array(entropyBits.match(/(.{1,8})/g).map(binaryToByte));
      assertEntropy(entropy);
      const newChecksum = await deriveChecksumBits(entropy);
      assert(
        newChecksum === checksumBits,
        'Invalid checksum'
      );

      return entropy;
    }

    /**
     * Converts raw entropy in form of byte array to mnemonic string.
     * @param entropy byte array
     * @param wordlist imported wordlist for specific language
     * @returns 12-24 words
     * @example
     * const ent = new Uint8Array([
     *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
     *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
     * ]);
     * await entropyToMnemonic(ent, wordlist);
     * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
     */
    async function entropyToMnemonic(entropy, wordlist) {
      assertEntropy(entropy);
      const entropyBits = bytesToBinary(entropy);
      const checksumBits = await deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{1,11})/g);
      const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
      });
      return words.join(isJapanese(wordlist) ? '\u3000' : ' ');
    }

    /**
     * Validates mnemonic for being 12-24 words contained in `wordlist`.
     */
    async function validateMnemonic(mnemonic, wordlist) {
      try {
        await mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }

    const salt = (passphrase) => nfkd(`mnemonic${passphrase}`);

    /**
     * Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
     * @param mnemonic 12-24 words
     * @param passphrase string that will additionally protect the key
     * @returns 64 bytes of key data
     * @example
     * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
     * await mnemonicToSeed(mnem, 'password');
     * // new Uint8Array([...64 bytes])
     */
    async function mnemonicToSeed(mnemonic, passphrase = '') {
      return pbkdf2(
        'SHA-512',
        normalize(mnemonic).nfkd,
        salt(passphrase),
        2048,
        64
      );
    }
  </script>

</body>

</html>